#' Extracts and stores tweets locally
#'
#' @param users A character vector of handles or id of Twitter users.
#' @param wait An integer, defaults to 1. Seconds to wait between requests to Twitter.
#' @param n An integer, number of new tweets to request per users, defaults to 100.
#' @param twitter_token A twitter token generated by rtweet.
#' @examples
#' 
#' @export

qf_get_tweets_by_user <- function(users,
                                  wait = 1,
                                  n = 100,
                                  twitter_token = NULL) {
  
  fs::dir_create(path = "tweets_by_user")
  
  local_tweet_locations <- fs::dir_ls(path = "tweets_by_user",
                                      recurse = FALSE,
                                      type = "file",
                                      glob = "*.rds")
  
  if (length(local_tweet_locations)==0) {
    existing_users <- NA
    new_users <- users
  } else {
    existing_users <- stringr::str_remove(string = fs::path_file(path = local_tweet_locations),
                                          pattern = stringr::fixed(".rds"))
    new_users <- users[is.element(el = users, set = existing_users)==FALSE]
    preexisting_users <- users[is.element(el = users, set = existing_users)==TRUE]
  }
  
  new_tweets <- tibble::tibble(users = new_users, new_tweets = NA)
  
  for (i in seq_along(new_users)) { 
    temp <- tryCatch(expr = rtweet::get_timeline(user = new_users[i],
                                                 n = n,
                                                 token = twitter_token),
                     error = function(e) {
                       update_tweets$newTweets[i] <- NA
                       NULL
                     })
    # if Twitter throws back anything looking real, add it to stored file
    if (is.null(temp)==FALSE) {
      if (nrow(temp)>0) {
        if (is.na(temp$screen_name[1])==FALSE){
          saveRDS(object = temp, file = fs::path("tweets_by_user", paste0(new_users[i], ".rds")))
          # store how many new tweets in data frame for reference
          new_tweets$new_tweets[i] <- nrow(temp)
          message(paste(new_tweets[i,], collapse = " - "))
          Sys.sleep(time = wait)
        }
      }
    }
  }
  # now process pre-existing users
  if (is.na(existing_users[1])==FALSE) {
    
    update_tweets <- tibble::tibble(users = preexisting_users,
                                    new_tweets = NA)
    
    for (i in seq_along(preexisting_users)) {  # start processing by oldest modified
      stored <- readRDS(file = fs::path("tweets_by_user",
                                        paste0(preexisting_users[i], ".rds")))
      if (is.null(stored)==FALSE) { # 
        # if there's an error, print it but go ahead
        temp <- tryCatch(expr = rtweet::get_timeline(user = preexisting_users[i],
                                                     n = n,
                                                     since_id = sum(max(as.numeric(stored$status_id)), 1),
                                                     token = twitter_token),
                         error = function(e) {
                           # do nothing
                         })
        # if Twitter throws back anything looking real, add it to stored file
        if (is.null(temp)==FALSE) {
          if (nrow(temp)>0) {
            if (is.na(temp$screen_name[1])==FALSE){
              pre_save <- dplyr::bind_rows(temp, stored) %>%
                dplyr::distinct(status_id, .keep_all = TRUE) %>%
                dplyr::arrange(created_at)
              saveRDS(object = pre_save,file = fs::path("tweets_by_user", paste0(preexisting_users[i], ".rds")))
              # store how many new tweets in data frame for reference
              update_tweets$new_tweets[i] <- nrow(pre_save)-nrow(stored)
              message(paste(paste(update_tweets[i,], collapse = " - "), "new tweets"))
              Sys.sleep(time = wait)
            }
          }
        }
      }
    }
    new_tweets <- dplyr::bind_rows(new_tweets, update_tweets)
  }
  # report back what has been downloaded
  new_tweets
}

#' Extracts and stores tweets locally based on Twitter lists
#'
#' @param n An integer, number of new tweets to request per users, defaults to 200.
#' @param cache_lists Logical, defaults to TRUE. If TRUE, stores locally the lists owned by a given user, in a subfolder `lists_by_user`. If list has already been downloaded, it just loads it. To overwrite, set `overwrite` to TRUE.
#' @param overwrite_lists Logical, defaults to FALSE. If TRUE, it overwrites previously downloaded lists.
#' @param twitter_token A twitter token generated by rtweet.
#' @examples
#' 
#' @export
#' 
qf_get_tweets_from_list <- function(list_id = NULL,
                                    slug = NULL,
                                    owner_user = NULL,
                                    since_id = NULL,
                                    max_id = NULL,
                                    n = 200,
                                    include_rts = TRUE,
                                    parse = TRUE,
                                    cache_lists = TRUE,
                                    overwrite_lists = FALSE,
                                    twitter_token = NULL) {
  if (is.null(list_id)==TRUE) {
    list_id <- qf_find_list_id(slug = slug,
                    owner_user = owner_user,
                    cache_lists = cache_lists,
                    overwrite_lists = overwrite_lists,
                    twitter_token = twitter_token)
  }
  fs::dir_create(path = fs::path("tweets_from_list", list_id), recurse = TRUE)
  local_tweets_location <- fs::dir_ls(path = fs::path("tweets_from_list", list_id),
                                      recurse = TRUE,
                                      type = "file",
                                      glob = "*.rds")
  if (length(local_tweets_location)==0) {
    today_folder <- fs::path("tweets_from_list", list_id, Sys.Date())
    fs::dir_create(path = today_folder, recurse = TRUE)
    tweets_from_list <- rtweet::lists_statuses(list_id = list_id,
                                               n = n,
                                               include_rts = include_rts,
                                               since_id = since_id,
                                               parse = parse,
                                               token = twitter_token)
    saveRDS(object = tweets_from_list,
            file = fs::path(today_folder,
                            paste0(Sys.time(), "-", "list_id.rds")))
  } else {
    previous_tweets <- readRDS(file = local_tweets_location %>% tail(1))
    if (is.null(since_id)==TRUE) {
      tweets_from_list <- rtweet::lists_statuses(list_id = list_id,
                                                 n = n,
                                                 since_id = max(as.numeric(previous_tweets$status_id)),
                                                 include_rts = include_rts,
                                                 parse = parse,
                                                 token = twitter_token)
    } else {
      tweets_from_list <- rtweet::lists_statuses(list_id = list_id,
                                                 n = n,
                                                 since_id = max(as.numeric(previous_tweets$status_id)),
                                                 include_rts = include_rts,
                                                 parse = parse,
                                                 token = twitter_token)
    }
    
    saveRDS(object = tweets_from_list,
            file = fs::path(today_folder,
                            paste0(Sys.time(), "-", "list_id.rds")))
  }
  return(tweets_from_list)
}